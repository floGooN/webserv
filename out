diff --git a/sources/Client.cpp b/sources/Client.cpp
index f90c0ea..5934c44 100644
--- a/sources/Client.cpp
+++ b/sources/Client.cpp
@@ -92,9 +92,6 @@ void	Client::checkRequestValidity() throw (ErrorHandler)
 	checkUriContent();
 
 	validTheUriPath();
-
-	std::cout	<< BRIGHT_GREEN "fullRequest:\n"
-				<< request << RESET;
 }
 /*----------------------------------------------------------------------------*/
 
diff --git a/sources/Cluster.cpp b/sources/Cluster.cpp
index 9f782c4..6cd4226 100644
--- a/sources/Cluster.cpp
+++ b/sources/Cluster.cpp
@@ -224,6 +224,7 @@ ssize_t	Cluster::safeRecv(const int clientFd, std::string &message)
 	
 	if ( ! bytesReceived || bytesReceived == -1 )
 	{
+		std::cout << RED << bytesReceived << RESET << std::endl;
 		if ( bytesReceived )
 			perror("recv()");
 		return bytesReceived;
@@ -269,8 +270,9 @@ void	Cluster::recvData(const struct epoll_event &event)
 	bytesReceived = safeRecv(event.data.fd, message);
 	checkByteReceived(event, bytesReceived);
 	currentClient = addClient(Request(message), event.data.fd);
+	currentClient->request.totalBytesReceived = bytesReceived;
 
-	while (bytesReceived == STATIC_BUFFSIZE)
+	while (currentClient->request.getbody().contentLength != currentClient->request.totalBytesReceived)
 	{
 		bytesReceived = safeRecv(event.data.fd, message);
 		checkByteReceived(event, bytesReceived);
@@ -282,6 +284,7 @@ void	Cluster::recvData(const struct epoll_event &event)
 			currentClient->clientServer->getParams().maxBodySize) {
 			throw ErrGenerator(findClient(event.data.fd), ERR_413, "Max body size reached");
 		}
+		currentClient->request.totalBytesReceived += bytesReceived;
 	}
 	// std::cout	<< BRIGHT_RED "HERE\n"
 	// 			<< "BODYSIZE: " << currentClient->request.getbody().body.size() << std::endl
diff --git a/sources/Request.cpp b/sources/Request.cpp
index 27b2e17..7fa490e 100644
--- a/sources/Request.cpp
+++ b/sources/Request.cpp
@@ -174,6 +174,7 @@ void Request::clearRequest()
 {
 	completeUri.clear();
 	keepAlive = false;
+	totalBytesReceived = 0;
 
 	_args.clear();
 	_header.clear();
diff --git a/sources/Request.hpp b/sources/Request.hpp
index 1cf23eb..e958429 100644
--- a/sources/Request.hpp
+++ b/sources/Request.hpp
@@ -30,6 +30,7 @@ class Request
 		void	updateRequest(const Request &req) throw(ErrorHandler);
 	
 		bool		keepAlive;
+		size_t		totalBytesReceived;
 		std::string	completeUri;
 
 	private:
diff --git a/sources/Response.cpp b/sources/Response.cpp
index a9d144e..535ecb2 100644
--- a/sources/Response.cpp
+++ b/sources/Response.cpp
@@ -91,8 +91,8 @@ void	Response::postQuery(Client &client)
 	{
 		if (client.request.getbody().contentType != MULTIPART)
 			throw ErrorHandler(ERR_415, "The media type is not supported by the server");
-		cleanBody(client.request);getsid
-		uploadFile(client.request);
+		
+		uploadFile(client);
 
 		client.request.completeUri = "./uploads/uploadSucces.html";
 		UtilParsing::readFile(client.request.completeUri, message);
@@ -116,23 +116,51 @@ void	Response::deleteQuery(const Client &)
 						/*### PRIVATE METHODS ###*/
 /*============================================================================*/
 
-void Response::uploadFile(const Request &req) throw (ErrorHandler)
+std::string Response::extractFilename(const std::string &bodyHeader) throw (ErrorHandler)
 {
-	// extract the name of the file
-	//  
-	const t_body	&ref = req.getbody();
-	size_t			iStart = ref.body.find_first_of("\r\n\r\n");
-	size_t			endOfFile = ref.body.find_last_of("\r\n\r\n");
-
-	std::cout << RED << ref.body << RESET;
+	std::cout << bodyHeader;
+	
+	size_t i = bodyHeader.find("filename=");
+	if (i == std::string::npos)
+		throw ErrorHandler(ERR_400, "The format of the request is wrong (missing filename)");
+	i += 9;
+	std::vector<std::string> res = UtilParsing::split(bodyHeader.substr(i, bodyHeader.find_first_of("\r\n") - i), "\"");
+	for (std::vector<std::string>::iterator it = res.begin(); it != res.end(); it++)
+	{
+		if (it->compare("\""))
+			return *it;
+	}	
+	return "";
+}
+/*----------------------------------------------------------------------------*/
 
-	if (iStart == std::string::npos || endOfFile == std::string::npos)
-		throw ErrorHandler(ERR_400, "No separator in the file to upload");
+void Response::uploadFile(const Client &client) throw (ErrorHandler)
+{
+	const t_body	&ref = client.request.getbody();
+	size_t			iStart = ref.body.find("\r\n\r\n");
 	
+	if (iStart== std::string::npos)
+		throw ErrorHandler(ERR_400, "No separator in the file to upload");
+		
+	std::string bodyHeader = ref.body.substr(0, iStart);
+		
+	size_t	endOfFile = ref.body.find(ref.bound, iStart);
+
+	if (endOfFile == std::string::npos)
+		throw ErrorHandler(ERR_400, "No EOF delimiter in the file to upload");
+
+	endOfFile = ref.body.find_last_of('\n', endOfFile);
+
 	iStart += 4;
-	endOfFile -= 4;
-	
+	endOfFile -= 1;
 	
+	std::string filename = client.request.completeUri + extractFilename(bodyHeader);
+
+	std::ofstream ss(filename.c_str(), std::ios::binary);
+	if (! ss)
+		throw ErrorHandler(ERR_500, "in uploadFile()");
+
+	ss.write(ref.body.c_str() + iStart, endOfFile - iStart);
 }
 /*----------------------------------------------------------------------------*/
 
diff --git a/sources/Response.hpp b/sources/Response.hpp
index de1195c..a1ebb8c 100644
--- a/sources/Response.hpp
+++ b/sources/Response.hpp
@@ -35,9 +35,10 @@ class Response
 		std::map<std::string, std::string>	_mimeMap;
 
 		void		initMimeMap();
-		void		uploadFile(const Request &) throw (ErrorHandler);
+		void		uploadFile(const Client &) throw (ErrorHandler);
 		bool		isCGI(const Request &) throw (ErrorHandler);
 		std::string	&findMimeType(const std::string &uri);
+		std::string extractFilename(const std::string &) throw (ErrorHandler);
 		std::string	setHeader(const Request &, const std::string &) throw (ErrorHandler);
 };
 
diff --git a/sources/includes/colors b/sources/includes/colors
index e76d35a..51382fc 100644
--- a/sources/includes/colors
+++ b/sources/includes/colors
@@ -6,7 +6,7 @@
 /*   By: fberthou <fberthou@student.42.fr>          +#+  +:+       +#+        */
 /*                                                +#+#+#+#+#+   +#+           */
 /*   Created: 2022/12/18 17:29:34 by mcombeau          #+#    #+#             */
-/*   Updated: 2025/01/22 11:55:04 by fberthou         ###   ########.fr       */
+/*   Updated: 2025/03/23 15:19:21 by fberthou         ###   ########.fr       */
 /*                                                                            */
 /* ************************************************************************** */
 
